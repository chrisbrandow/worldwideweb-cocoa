#!/usr/bin/env python3

# A small tool to convert a legacy NeXTStep NIB bundle to a modern Interface
# Builder XIB that recent versions of Xcode (e.g. 15.4) can read. Note that
# the tool cannot handle many of the newer versions of the NIB file format
# and is expressly built to handle the reverse engineered WorldWideWeb.nib

from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Iterable

import argparse
import typedstream
import xml.etree.ElementTree as ET

# TODO: Reverse-engineer the parameters of some common classes (e.g. View)
# TODO: Use a better order for "expanding" referenced objects (e.g. breadth-first)
# TODO: Generate a "modern" XIB and perhaps only keep the old one around as a reference

@dataclass
class State:
    visited_objects: set[typedstream.GenericArchivedObject] = field(default_factory=set)

def convert_value(value: Any, state: State) -> ET.Element:
    if value is None:
        return ET.Element('nil')
    elif isinstance(value, int):
        element = ET.Element('int')
        element.text = str(value)
        return element
    elif isinstance(value, float):
        element = ET.Element('float')
        element.text = str(value)
        return element
    elif isinstance(value, bytes):
        element = ET.Element('string')
        element.text = value.decode()
        return element
    elif isinstance(value, typedstream.Class):
        element = ET.Element('class', attrib={'name': value.name.decode(), **({'superclass': value.superclass.name.decode()} if value.superclass else {})})
        return element
    elif isinstance(value, typedstream.GenericArchivedObject):
        if value in state.visited_objects:
            return ET.Element('reference', attrib={'class': value.clazz.name.decode(), 'ref': str(id(value))})
        state.visited_objects.add(value)

        return convert_object(value, name='object', state=state)
    elif isinstance(value, typedstream.types.nextstep.List):
        element = ET.Element('list')
        for item in value.elements:
            element.append(convert_value(item, state=state))
        return element
    else:
        return ET.Element('unknown', attrib={'name': str(type(value))})

def convert_group(group: typedstream.TypedGroup, state: State) -> Iterable[ET.Element]:
    for value in group.values:
        yield convert_value(value, state=state)

def convert_object(object: typedstream.GenericArchivedObject, name: str, state: State) -> ET.Element:
    element = ET.Element(name, attrib={'class': object.clazz.name.decode(), 'id': str(id(object))} if name == 'object' else {})

    for group in object.contents:
        group_element = ET.SubElement(element, 'group')
        for value in convert_group(group, state=state):
            group_element.append(value)

    return element

def convert_root(object: typedstream.GenericArchivedObject) -> ET.ElementTree:
    root = ET.Element('archive', attrib={
        'type': 'com.apple.InterfaceBuilder3.Cocoa.XIB',
        'version': '7.10',
    })
    root.append(ET.Comment('NOTE: This file is autogenerated using the (highly work-in-progress) convert-nib-to-xib script'))
    root.append(convert_object(object, name='data', state=State()))

    xib = ET.ElementTree(root)
    ET.indent(xib, space=' ' * 2)
    return xib

def main():
    parser = argparse.ArgumentParser(description='Converts a legacy NeXTStep NIB to XIB.')
    parser.add_argument('-o', '--output', required=True, type=Path, help='The path to the output XIB.')
    parser.add_argument('input', type=Path, help='The path to the input NIB.')

    args = parser.parse_args()

    nib = typedstream.unarchive_from_file(args.input / 'data.nib')

    xib = convert_root(nib)
    xib.write(args.output, encoding='utf-8', xml_declaration=True)

if __name__ == '__main__':
    main()
